<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Traverse the binary tree]]></title>
    <url>%2F2017%2F08%2F30%2FTraverse%20the%20binary%20tree%2F</url>
    <content type="text"><![CDATA[前几天做到不少关于二叉树的题,二叉树最基本的问题就是各种遍历,于是找时间整理了一下. 遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。 二叉树的遍历一般有四种: 先序遍历 首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树 中序遍历 首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树 后续遍历 首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根 层序遍历 按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低）（两个子女的级别相同） 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 先序遍历，中序遍历，后续遍历 时间复杂度为O(n) * 层序遍历 时间复杂度为O(logn),最坏的情况下时间复杂度为O(n^2) * @author Administrator * */class TreeNode&#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123;this.val = x;&#125;&#125;public class Test &#123; //先序遍历 public static void firstSearch(TreeNode root) &#123; if(root == null) return; System.out.print(root.val+" "); if(root.left!=null) firstSearch(root.left); if(root.right!=null) firstSearch(root.right); &#125; //中序遍历 public static void middleSerach(TreeNode root) &#123; if(root == null) return; if(root.left!=null) middleSerach(root.left); System.out.print(root.val+" "); if(root.right!=null) middleSerach(root.right); &#125; //后续遍历 public static void lastSearch(TreeNode root) &#123; if(root == null) return; if(root.left!=null) lastSearch(root.left); if(root.right!=null) lastSearch(root.right); System.out.print(root.val+" "); &#125; //层序遍历 public static void levalSearch(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); int leval = 0; while(!queue.isEmpty()) &#123; int n = queue.size(); for(int i=0;i&lt;n;i++) &#123; TreeNode treeNode = queue.poll(); System.out.print(treeNode.val+" "); if(treeNode.left!=null) queue.add(treeNode.left); if(treeNode.right!=null) queue.add(treeNode.right); &#125; System.out.println(" 第"+(leval++)+"层"); &#125; &#125;&#125; 对于一个二叉树12345678结果为先序遍历:1 2 4 5 3 6 7 中序遍历:4 2 5 1 6 3 7 后续遍历:4 5 2 6 7 3 1 层序遍历:1 第0层2 3 第1层4 5 6 7 第2层]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[543.Diameter of Binary Tree]]></title>
    <url>%2F2017%2F08%2F05%2F543.Diameter%20of%20Binary%20Tree%2F</url>
    <content type="text"><![CDATA[题目描述Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.给定一个二叉树，计算任意两个节点之间最长路径的长度12345 1 / \ 2 3 / \4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].这是一个简单的动态规划的问题，通过深度遍历求最低节点所构成子树的最长路径，然后依次向上，保留路径的最大值，最终结果就是给定二叉树的最长路径。 实现代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int maxlen = 0; public int maxdep(TreeNode root) &#123; if(root == null) return 0; int left = maxdep(root.left); int right = maxdep(root.right); maxlen = Math.max(maxlen,left+right); return Math.max(left,right)+1; &#125; public int diameterOfBinaryTree(TreeNode root) &#123; maxdep(root); return maxlen; &#125;&#125; Runtime: 9 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[371.Sum of Two Integers]]></title>
    <url>%2F2017%2F08%2F03%2F371.Sum%20of%20Two%20Integers%2F</url>
    <content type="text"><![CDATA[题目描述Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.不使用加减号计算两个整数的和，找到了两种方法。 方法一1234567public int getSum(int a, int b) &#123; if(0 == b) return a; int cxor = a^b; int cand = a&amp;b; return getSum(cxor, cand&lt;&lt;1); &#125; 1.在二进制下,不考虑进位将a,b相加,即a^b.2.只考虑进位,即a&amp;b.3.将a&amp;b向前进一位.4.此时a+b就可以转化为另外两个数的和,直至b为0. 方法二1234int getSum(int a, int b) &#123; char *c = (char *)a; return (long) &amp;c[b]; &#125; 1.首先将a转换为地址类型,指针c指向该地址.2.c[b]就是相当于平时数组中的取下标为b的元素的值,就是说c[b]=c+sizeof(char*)b.3.因为c是指针，所以c[b]指向的是地址内的值,用&amp;来将该地址对应的值的地址取出来.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Operator</tag>
      </tags>
  </entry>
</search>