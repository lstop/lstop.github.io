<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[543.Diameter of Binary Tree]]></title>
    <url>%2F2017%2F08%2F05%2F543.Diameter%20of%20Binary%20Tree%2F</url>
    <content type="text"><![CDATA[#题目描述 Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. 给定一个二叉树，计算任意两个节点之间最长路径的长度 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].这是一个简单的动态规划的问题，通过深度遍历求最低节点所构成子树的最长路径，然后依次向上，保留路径的最大值，最终结果就是给定二叉树的最长路径。下面给出Java实现代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; int maxlen = 0; public int maxdep(TreeNode root) &#123; if(root == null) return 0; int left = maxdep(root.left); int right = maxdep(root.right); maxlen = Math.max(maxlen,left+right); return Math.max(left,right)+1; &#125; public int diameterOfBinaryTree(TreeNode root) &#123; maxdep(root); return maxlen; &#125;&#125; Runtime: 9 ms]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友情链接]]></title>
    <url>%2F2017%2F08%2F04%2F%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[#下面是一些网站的传送门]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[371.Sum of Two Integers]]></title>
    <url>%2F2017%2F08%2F03%2F371.Sum%20of%20Two%20Integers%2F</url>
    <content type="text"><![CDATA[#题目描述Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.不使用加减号计算两个整数的和，找到了两种方法。 ##方法一1234567public int getSum(int a, int b) &#123; if(0 == b) return a; int cxor = a^b; int cand = a&amp;b; return getSum(cxor, cand&lt;&lt;1); &#125; 1.在二进制下,不考虑进位将a,b相加,即a^b.2.只考虑进位,即a&amp;b.3.将a&amp;b向前进一位.4.此时a+b就可以转化为另外两个数的和,直至b为0. ##方法二1234int getSum(int a, int b) &#123; char *c = (char *)a; return (long) &amp;c[b]; &#125; 1.首先将a转换为地址类型,指针c指向该地址.2.c[b]就是相当于平时数组中的取下标为b的元素的值,就是说c[b]=c+sizeof(char*)b.3.因为c是指针，所以c[b]指向的是地址内的值,用&amp;来将该地址对应的值的地址取出来.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Operator</tag>
      </tags>
  </entry>
</search>